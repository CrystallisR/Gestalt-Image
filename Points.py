# CrystallisR 2022
import numpy as np
import matplotlib.pyplot as plt
import random

# return a function by id
# id can be a randomly generated number
def randomFunc(id):
    if id == 0:
        return lambda x : 1
    elif id == 1:
        return lambda x : x
    elif id == 2:
        return lambda x: x**2
    elif id == 3:
        return lambda x: x**0.5
    elif id == 4:
        return lambda x: np.log(x)
    elif id == 5:
        return lambda x: np.exp(x)
    elif id == 6:
        return lambda x: x**2 - 2*x
    elif id == 7:
        return lambda x: x**3 -2*x**2 + x
    elif id == 8:
        return lambda x: np.exp(x) - np.log(x)
    else:
        return lambda x : 1/(1 + np.exp(-x))

# return (x, y) coordinates of a set of points
'''
<parameters>
isN = whether use the symmetric function of the function generated by randomFunc()
p_num = maximal point number
funcs = total number of functions which can be generated by randomFunc()
n_min & n_max control the range of numbers of generated points

'''
def setPoints(isN, p_num=10, funcs=10, n_min=0.6, n_max=1.0):
    # set total points of a curve & curve type
    tl_pts = random.randint(int(p_num*n_min), int(p_num*n_max))
    x_list = list(range(1, tl_pts+1))
    rd_func = randomFunc(random.randint(0, funcs))
    y_list = [rd_func(x) for x in x_list]
    scale = tl_pts/max(y_list)
    y_list = [y*scale for y in y_list]
    if isN: y_list.reverse()
    return x_list, y_list

# after points are set, adding some Noise to make the points more disordered
'''
<parameters>
intensity = the degree of noise intended to add

'''
def addNoise(x_list, y_list, intensity=1.0):
    # generate noise
    nx_list = [x + np.random.normal(scale=intensity) for x in x_list]
    ny_list = [y + np.random.normal(scale=intensity) for y in y_list]
    return nx_list, ny_list

# draw points on a figure
'''
<parameters>
path = where to save the figure
num = number of lines or curves
img_sz = width & height ratio of the image
dpi = resolution
psz = point size
colors = list of colors

'''
def drawPoints(path, num=2, img_sz=(1, 1), dpi=128, psz=10, colors=["black"], markers=["."]):
    # number of colors should be consistent with line numbers 
    c_num, m_num = len(colors), len(markers)
    c_num = len(colors)
    plt.figure(figsize=img_sz, dpi=dpi)
    x_list1, y_list1 = setPoints(True)
    x_list2, y_list2 = setPoints(False)
    plt.scatter(x_list1, y_list1, s=psz, c=colors[random.randint(0, c_num-1)], marker=markers[random.randint(0, m_num-1)])
    plt.scatter(x_list2, y_list2, s=psz, c=colors[random.randint(0, c_num-1)], marker=markers[random.randint(0, m_num-1)])
    if num > 1:
        for _ in range(num-2):
            fg = True if random.randint(0,1) == 1 else False
            x_list, y_list = setPoints(fg)
            plt.scatter(x_list, y_list, s=psz, c=colors[random.randint(0, c_num-1)], marker=markers[random.randint(0, m_num-1)])
    plt.axis('off')
    plt.savefig(path)

# draw points with noise on a figure
'''
<parameters>
path = where to save the figure
num = number of lines or curves
img_sz = width & height ratio of the image
dpi = resolution
psz = point size
intensity = the degree of noise intended to add
colors = list of colors
markers = list of markers

'''  
def drawPointsNoise(path, num=2, img_sz=(1, 1), dpi=128, psz=10, intensity=1.0, colors=["black"], markers=["."]):
    # number of colors should be consistent with line numbers 
    c_num, m_num = len(colors), len(markers)
    c_num = len(colors)
    plt.figure(figsize=img_sz, dpi=dpi)
    x_list1, y_list1 = setPoints(True)
    x_list2, y_list2 = setPoints(False)
    x_list1, y_list1 = addNoise(x_list1, y_list1, intensity)
    x_list2, y_list2 = addNoise(x_list2, y_list2, intensity)
    plt.scatter(x_list1, y_list1, s=psz, c=colors[random.randint(0, c_num-1)], marker=markers[random.randint(0, m_num-1)])
    plt.scatter(x_list2, y_list2, s=psz, c=colors[random.randint(0, c_num-1)], marker=markers[random.randint(0, m_num-1)])
    if num > 1:
        for _ in range(num-2):
            fg = True if random.randint(0,1) == 1 else False
            x_list, y_list = setPoints(fg)
            x_list, y_list = addNoise(x_list, y_list, intensity)
            plt.scatter(x_list, y_list, s=psz, c=colors[random.randint(0, c_num-1)], marker=markers[random.randint(0, m_num-1)])
    plt.axis('off')
    plt.savefig(path)
    
# draw points on a subfigure
# draw multiple subfigures on a figure
# for display purpose
def drawPointsMul(path, num_range=(2, 5), plots=(5, 5), dpi=128, psz=10, colors=["black"], markers=["."]):
    c_num, m_num = len(colors), len(markers)
    fig = plt.figure(figsize=plots, dpi=dpi)
    rows, cols = plots[0], plots[1]
    for i in range(1, rows*cols+1):
        fig.add_subplot(rows, cols, i)
        x_list1, y_list1 = setPoints(True)
        x_list2, y_list2 = setPoints(False)
        plt.scatter(x_list1, y_list1, s=psz, c=colors[random.randint(0, c_num-1)], marker=markers[random.randint(0, m_num-1)])
        plt.scatter(x_list2, y_list2, s=psz, c=colors[random.randint(0, c_num-1)], marker=markers[random.randint(0, m_num-1)])
        num = random.randint(num_range[0], num_range[1])
        if num > 1:
            for _ in range(num-2):
                fg = True if random.randint(0,1) == 1 else False
                x_list, y_list = setPoints(fg)
                plt.scatter(x_list, y_list, s=psz, c=colors[random.randint(0, c_num-1)], marker=markers[random.randint(0, m_num-1)])
        plt.axis('off')
    plt.savefig(path)